<?xml version="1.0" encoding="UTF-8"?>
<hadolint-rules>
	<rule>
		<key>Hadolint.DL3000</key>
		<name><![CDATA[Use absolute WORKDIR.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				By using absolute paths you will not run into problems when a previous <b>WORKDIR</b> instruction changes.<br/>
				You also often times don't know the <b>WORKDIR</b> context of your base container.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
WORKDIR usr/src/app</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
WORKDIR /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When using environment replacements.
				<pre>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar</pre>
			</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3001</key>
		<name><![CDATA[Command does not make sense in a container.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				For some POSIX commands it makes no sense to run them in a Docker container because they are bound to the host or are otherwise dangerous (like ´shutdown´, ´service´, ´ps´, ´free´, ´top´, ´kill´, ´mount´, ´ifconfig´). Interactive utilities also don't make much sense (´nano´, ´vim´).
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN top</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3002</key>
		<name><![CDATA[Last user should not be root.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Switching to the root <b>USER</b> opens up certain security risks if an attacker gets access to the container. In order to mitigate this, switch back to a non privileged user after running the commands you need as root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
USER root
RUN ...</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
USER root
RUN ...
USER guest</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3003</key>
		<name><![CDATA[Use WORKDIR to switch to a directory.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Only use <b>cd</b> in a subshell. Most commands can work with absolute paths and it in most cases not necessary to change directories. Docker provides the <b>WORKDIR</b> instruction if you really need to change the current working directory.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN cd /usr/src/app && git clone git@github.com:lukasmartinelli/hadolint.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN git clone git@github.com:lukasmartinelli/hadolint.git /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When executed in a Subshell.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3004</key>
		<name><![CDATA[Do not use sudo.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Do not use sudo as it leads to unpredictable behavior. Use a tool like gosu to enforce root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN sudo apt-get install</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3005</key>
		<name><![CDATA[Do not use apt-get upgrade or dist-upgrade.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html">http://crosbymichael.com/dockerfile-best-practices-take-2.html</a>
				<blockquote>Updates will be baked into the base images, so you don't need to run apt-get upgrade in your containers. Because of the isolation that happens this can often fail if something is trying to modify init or make device changes inside a container. It also produces inconsistent images because you no longer have one source of truth of how your application should run and what versions of dependencies are included in the image.</blockquote>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>You should avoid <b>RUN apt-get upgrade</b> or <b>RUN apt-get dist-upgrade</b>, as many of the “essential” packages from the base images won’t upgrade inside an unprivileged container. If a package contained in the base image is out-of-date, you should contact its maintainers.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get update && apt-get upgrade </pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get update</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3006</key>
		<name><![CDATA[Always tag the version of an image explicitly.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>
			<h2>Exceptions :</h2>
			<p>When the image name refers to a previously defined alias:</p>
			<pre>FROM debian:jessie as build
RUN build_script
FROM build as tests
RUN test_script
FROM debian:jessie
COPY --from=build foo .</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3007</key>
		<name><![CDATA[Using latest is prone to errors if the image will ever update. Pin the version explicitly to a release tag.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:latest</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3008</key>
		<name><![CDATA[Pin versions in apt get install.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt-get install python</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install python=2.7</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3009</key>
		<name><![CDATA[Delete the apt-get lists after installing something.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>In addition, cleaning up the apt cache and removing /var/lib/apt/lists helps keep the image size down. Since the RUN statement starts with apt-get update, the package cache will always be refreshed prior to apt-get install.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>RUN apt-get update && apt-get install -y python</pre>
			<h2>Correct code :</h2>
			<pre>RUN apt-get update && apt-get install -y python \
 && apt-get clean \
 && rm -rf /var/lib/apt/lists/*</pre>
 			<h2>Notes :</h2>
			<p>Clean up must be performed in the same RUN step, otherwise it will not affect image size.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3010</key>
		<name><![CDATA[Use ADD for extracting archives into an image.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.</blockquote>
			</p>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3011</key>
		<name><![CDATA[Valid UNIX ports range from 0 to 65535.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
EXPOSE 80000</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
EXPOSE 65535</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3013</key>
		<name><![CDATA[Pin versions in pip.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM python:3.4
RUN pip install django
RUN pip install https://github.com/Banno/carbon/tarball/0.9.x-fix-events-callback</pre>
			<h2>Correct code :</h2>
			<pre>FROM python:3.4
RUN pip install django==1.9
RUN pip install git+https://github.com/Banno/carbon@0.9.15</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3014</key>
		<name><![CDATA[Use the -y switch.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Without the <b>--assume-yes</b> option it might be possible that the build breaks without human intervention.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get install python=2.7</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get install -y python=2.7</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3015</key>
		<name><![CDATA[Avoid additional packages by specifying --no-install-recommends.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Avoid installing additional packages that you did not explicitly want.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt-get install -y python=2.7</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install -y --no-install-recommends python=2.7</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3016</key>
		<name><![CDATA[Pin versions in npm.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.
				<blockquote><a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM node:8.9.1

RUN npm install express
RUN npm install @myorg/privatepackage
RUN npm install express sax@0.1.1
RUN npm install --global express
RUN npm install git+ssh://git@github.com:npm/npm.git
RUN npm install git+http://isaacs@github.com/npm/npm
RUN npm install git+https://isaacs@github.com/npm/npm.git
RUN npm install git://github.com/npm/npm.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM node:8.9.1

RUN npm install express@4.1.1
RUN npm install @myorg/privatepackage@">=0.1.0"
RUN npm install express@"4.1.1" sax@0.1.1
RUN npm install --global express@"4.1.1"
RUN npm install git+ssh://git@github.com:npm/npm.git#v1.0.27
RUN npm install git+http://isaacs@github.com/npm/npm#semver:^5.0
RUN npm install git+https://isaacs@github.com/npm/npm.git#v1.0.27
RUN npm install git://github.com/npm/npm.git#v1.0.27</pre>
			<h2>Exceptions :</h2>
			<p>Pin your versions in <b>package.json</b> and run <b>npm install</b> with no arguments.</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3017</key>
		<name><![CDATA[Do not use apk upgrade]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You should avoid <b>RUN apk upgrade</b>, as many of the “essential” packages from the parent images won’t upgrade inside an unprivileged container. If a package contained in the parent image is out-of-date, you should contact its maintainers. If you know there’s a particular package, <b>foo</b>, that needs to be updated, use <b>apk --no-cache add foo</b> to update automatically.
				<blockquote>inspired by <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk update \
    && apk upgrade \
    && apk add foo=1.0 \
    && rm -rf /var/cache/apk/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.0</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3018</key>
		<name><![CDATA[Pin versions in apk add]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Version pinning forces the build to retrieve a limited range of versions, or an exact particular version, regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.
				<blockquote><a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo</pre>
			<h2>Correct code (Partial pin glob):</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=~1.23</pre>
			<h2>Correct code (Exact pin):</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.23</pre>
			<p><b>Note:</b> Pinning exact versions can cause future builds to suddenly fail if that version is no longer available. Use with caution.</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3019</key>
		<name><![CDATA[Use the --no-cache switch]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				As of Alpine Linux 3.3 there exists a new <b>--no-cache</b> option for <b>apk</b>. It allows users to install packages with an index that is updated and used on-the-fly and not cached locally:</br>
This avoids the need to use <b>--update</b> and remove <b>/var/cache/apk/*</b> when done installing packages.
				<blockquote>inspired by <a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/usage.md#disabling-cache">https://github.com/gliderlabs/docker-alpine/blob/master/docs/usage.md#disabling-cache</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk update \
    && apk add foo=1.0 \
    && rm -rf /var/cache/apk/*</pre>
			<pre>FROM alpine:3.7
RUN apk add --update foo=1.0
    && rm -rf /var/cache/apk/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.0</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3020</key>
		<name><![CDATA[Use COPY instead of ADD for files and folders]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy</a>
				<blockquote>For other items (files, directories) that do not require ADD’s tar auto-extraction capability, you should always use COPY.</blockquote>
				Rule also implemented in <a href="https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee">https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee</a>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM python:3.4
ADD requirements.txt /usr/src/app/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM python:3.4
COPY requirements.txt /usr/src/app/</pre>
			]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>

</hadolint-rules>