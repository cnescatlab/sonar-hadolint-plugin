<?xml version="1.0" encoding="UTF-8"?>
<hadolint-rules>
	<rule>
		<key>Hadolint.DL3000</key>
		<name><![CDATA[Use absolute WORKDIR.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				By using absolute paths you will not run into problems when a previous <b>WORKDIR</b> instruction changes.<br/>
				You also often times don't know the <b>WORKDIR</b> context of your base container.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
WORKDIR usr/src/app</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
WORKDIR /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When using environment replacements.
				<pre>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar</pre>
			</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3001</key>
		<name><![CDATA[Command does not make sense in a container.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				For some POSIX commands it makes no sense to run them in a Docker container because they are bound to the host or are otherwise dangerous (like ´shutdown´, ´service´, ´ps´, ´free´, ´top´, ´kill´, ´mount´, ´ifconfig´). Interactive utilities also don't make much sense (´nano´, ´vim´).
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN top</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3002</key>
		<name><![CDATA[Last user should not be root.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Switching to the root <b>USER</b> opens up certain security risks if an attacker gets access to the container. In order to mitigate this, switch back to a non privileged user after running the commands you need as root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
USER root
RUN ...</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
USER root
RUN ...
USER guest</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3003</key>
		<name><![CDATA[Use WORKDIR to switch to a directory.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Only use <b>cd</b> in a subshell. Most commands can work with absolute paths and it in most cases not necessary to change directories. Docker provides the <b>WORKDIR</b> instruction if you really need to change the current working directory.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN cd /usr/src/app && git clone git@github.com:lukasmartinelli/hadolint.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN git clone git@github.com:lukasmartinelli/hadolint.git /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When executed in a Subshell.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3004</key>
		<name><![CDATA[Do not use sudo.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Do not use sudo as it leads to unpredictable behavior. Use a tool like gosu to enforce root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN sudo apt-get install</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3005</key>
		<name><![CDATA[Do not use apt-get upgrade or dist-upgrade.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html">http://crosbymichael.com/dockerfile-best-practices-take-2.html</a>
				<blockquote>Updates will be baked into the base images, so you don't need to run apt-get upgrade in your containers. Because of the isolation that happens this can often fail if something is trying to modify init or make device changes inside a container. It also produces inconsistent images because you no longer have one source of truth of how your application should run and what versions of dependencies are included in the image.</blockquote>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>You should avoid <b>RUN apt-get upgrade</b> or <b>RUN apt-get dist-upgrade</b>, as many of the “essential” packages from the base images won’t upgrade inside an unprivileged container. If a package contained in the base image is out-of-date, you should contact its maintainers.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get update && apt-get upgrade </pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get update</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>

</hadolint-rules>