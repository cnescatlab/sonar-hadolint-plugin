<?xml version="1.0" encoding="UTF-8"?>
<hadolint-rules>
	<rule>
		<key>Hadolint.DL3000</key>
		<name><![CDATA[Use absolute WORKDIR.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				By using absolute paths you will not run into problems when a previous <b>WORKDIR</b> instruction changes.<br/>
				You also often times don't know the <b>WORKDIR</b> context of your base container.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
WORKDIR usr/src/app</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
WORKDIR /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When using environment replacements.
				<pre>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar</pre>
			</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3001</key>
		<name><![CDATA[Command does not make sense in a container.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				For some POSIX commands it makes no sense to run them in a Docker container because they are bound to the host or are otherwise dangerous (like ´shutdown´, ´service´, ´ps´, ´free´, ´top´, ´kill´, ´mount´, ´ifconfig´). Interactive utilities also don't make much sense (´nano´, ´vim´).
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN top</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3002</key>
		<name><![CDATA[Last user should not be root.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Switching to the root <b>USER</b> opens up certain security risks if an attacker gets access to the container. In order to mitigate this, switch back to a non privileged user after running the commands you need as root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
USER root
RUN ...</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
USER root
RUN ...
USER guest</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3003</key>
		<name><![CDATA[Use WORKDIR to switch to a directory.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Only use <b>cd</b> in a subshell. Most commands can work with absolute paths and it in most cases not necessary to change directories. Docker provides the <b>WORKDIR</b> instruction if you really need to change the current working directory.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN cd /usr/src/app && git clone git@github.com:lukasmartinelli/hadolint.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN git clone git@github.com:lukasmartinelli/hadolint.git /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When executed in a Subshell.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3004</key>
		<name><![CDATA[Do not use sudo.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Do not use sudo as it leads to unpredictable behavior. Use a tool like gosu to enforce root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN sudo apt-get install</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3005</key>
		<name><![CDATA[Do not use apt-get upgrade or dist-upgrade.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html">http://crosbymichael.com/dockerfile-best-practices-take-2.html</a>
				<blockquote>Updates will be baked into the base images, so you don't need to run apt-get upgrade in your containers. Because of the isolation that happens this can often fail if something is trying to modify init or make device changes inside a container. It also produces inconsistent images because you no longer have one source of truth of how your application should run and what versions of dependencies are included in the image.</blockquote>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>You should avoid <b>RUN apt-get upgrade</b> or <b>RUN apt-get dist-upgrade</b>, as many of the “essential” packages from the base images won’t upgrade inside an unprivileged container. If a package contained in the base image is out-of-date, you should contact its maintainers.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get update && apt-get upgrade </pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get update</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3006</key>
		<name><![CDATA[Always tag the version of an image explicitly.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>
			<h2>Exceptions :</h2>
			<p>When the image name refers to a previously defined alias:</p>
			<pre>FROM debian:jessie as build
RUN build_script
FROM build as tests
RUN test_script
FROM debian:jessie
COPY --from=build foo .</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3007</key>
		<name><![CDATA[Using latest is prone to errors if the image will ever update. Pin the version explicitly to a release tag.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:latest</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3008</key>
		<name><![CDATA[Pin versions in apt get install.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt-get install python</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install python=2.7</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3009</key>
		<name><![CDATA[Delete the apt-get lists after installing something.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>In addition, cleaning up the apt cache and removing /var/lib/apt/lists helps keep the image size down. Since the RUN statement starts with apt-get update, the package cache will always be refreshed prior to apt-get install.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>RUN apt-get update && apt-get install -y python</pre>
			<h2>Correct code :</h2>
			<pre>RUN apt-get update && apt-get install -y python \
 && apt-get clean \
 && rm -rf /var/lib/apt/lists/*</pre>
 			<h2>Notes :</h2>
			<p>Clean up must be performed in the same RUN step, otherwise it will not affect image size.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3010</key>
		<name><![CDATA[Use ADD for extracting archives into an image.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.</blockquote>
			</p>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3011</key>
		<name><![CDATA[Valid UNIX ports range from 0 to 65535.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
EXPOSE 80000</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
EXPOSE 65535</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3013</key>
		<name><![CDATA[Pin versions in pip.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM python:3.4
RUN pip install django
RUN pip install https://github.com/Banno/carbon/tarball/0.9.x-fix-events-callback</pre>
			<h2>Correct code :</h2>
			<pre>FROM python:3.4
RUN pip install django==1.9
RUN pip install git+https://github.com/Banno/carbon@0.9.15</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3014</key>
		<name><![CDATA[Use the -y switch.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Without the <b>--assume-yes</b> option it might be possible that the build breaks without human intervention.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get install python=2.7</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get install -y python=2.7</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>

</hadolint-rules>