<?xml version="1.0" encoding="UTF-8"?>
<hadolint-rules>
	<rule>
		<key>Hadolint.DL3000</key>
		<name><![CDATA[Use absolute WORKDIR.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				By using absolute paths you will not run into problems when a previous <b>WORKDIR</b> instruction changes.<br/>
				You also often times don't know the <b>WORKDIR</b> context of your base container.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
WORKDIR usr/src/app</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
WORKDIR /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When using environment replacements.
				<pre>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar</pre>
			</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3001</key>
		<name><![CDATA[Command does not make sense in a container.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				For some POSIX commands it makes no sense to run them in a Docker container because they are bound to the host or are otherwise dangerous (like ´shutdown´, ´service´, ´ps´, ´free´, ´top´, ´kill´, ´mount´, ´ifconfig´). Interactive utilities also don't make much sense (´nano´, ´vim´).
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN top</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3002</key>
		<name><![CDATA[Last user should not be root.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Switching to the root <b>USER</b> opens up certain security risks if an attacker gets access to the container. In order to mitigate this, switch back to a non privileged user after running the commands you need as root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
USER root
RUN ...</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
USER root
RUN ...
USER guest</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3003</key>
		<name><![CDATA[Use WORKDIR to switch to a directory.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Only use <b>cd</b> in a subshell. Most commands can work with absolute paths and it in most cases not necessary to change directories. Docker provides the <b>WORKDIR</b> instruction if you really need to change the current working directory.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN cd /usr/src/app && git clone git@github.com:lukasmartinelli/hadolint.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN git clone git@github.com:lukasmartinelli/hadolint.git /usr/src/app</pre>
			<h2>Exceptions :</h2>
			<p>When executed in a Subshell.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3004</key>
		<name><![CDATA[Do not use sudo.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Do not use sudo as it leads to unpredictable behavior. Use a tool like gosu to enforce root.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN sudo apt-get install</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3005</key>
		<name><![CDATA[Do not use apt-get upgrade or dist-upgrade.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html">http://crosbymichael.com/dockerfile-best-practices-take-2.html</a>
				<blockquote>Updates will be baked into the base images, so you don't need to run apt-get upgrade in your containers. Because of the isolation that happens this can often fail if something is trying to modify init or make device changes inside a container. It also produces inconsistent images because you no longer have one source of truth of how your application should run and what versions of dependencies are included in the image.</blockquote>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>You should avoid <b>RUN apt-get upgrade</b> or <b>RUN apt-get dist-upgrade</b>, as many of the “essential” packages from the base images won’t upgrade inside an unprivileged container. If a package contained in the base image is out-of-date, you should contact its maintainers.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get update && apt-get upgrade </pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get update</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3006</key>
		<name><![CDATA[Always tag the version of an image explicitly.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>
			<h2>Exceptions :</h2>
			<p>When the image name refers to a previously defined alias:</p>
			<pre>FROM debian:jessie as build
RUN build_script
FROM build as tests
RUN test_script
FROM debian:jessie
COPY --from=build foo .</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3007</key>
		<name><![CDATA[Using latest is prone to errors if the image will ever update. Pin the version explicitly to a release tag.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You can never rely that the <b>latest</b> tags is a specific version.
				<a href="https://docs.docker.com/engine/userguide/dockerimages/">https://docs.docker.com/engine/userguide/dockerimages/</a>
				<blockquote>Tip: You recommend you always use a specific tagged image, for example ubuntu:12.04. That way you always know exactly what variant of an image is being used.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:latest</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jessie</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3008</key>
		<name><![CDATA[Pin versions in apt get install.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#apt-get</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt-get install python</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install python=2.7</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3009</key>
		<name><![CDATA[Delete the apt-get lists after installing something.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>In addition, cleaning up the apt cache and removing /var/lib/apt/lists helps keep the image size down. Since the RUN statement starts with apt-get update, the package cache will always be refreshed prior to apt-get install.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>RUN apt-get update && apt-get install -y python</pre>
			<h2>Correct code :</h2>
			<pre>RUN apt-get update && apt-get install -y python \
 && apt-get clean \
 && rm -rf /var/lib/apt/lists/*</pre>
 			<h2>Notes :</h2>
			<p>Clean up must be performed in the same RUN step, otherwise it will not affect image size.</p>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3010</key>
		<name><![CDATA[Use ADD for extracting archives into an image.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.</blockquote>
			</p>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3011</key>
		<name><![CDATA[Valid UNIX ports range from 0 to 65535.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
EXPOSE 80000</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
EXPOSE 65535</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3013</key>
		<name><![CDATA[Pin versions in pip.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
				<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM python:3.4
RUN pip install django
RUN pip install https://github.com/Banno/carbon/tarball/0.9.x-fix-events-callback</pre>
			<h2>Correct code :</h2>
			<pre>FROM python:3.4
RUN pip install django==1.9
RUN pip install git+https://github.com/Banno/carbon@0.9.15</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3014</key>
		<name><![CDATA[Use the -y switch.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Without the <b>--assume-yes</b> option it might be possible that the build breaks without human intervention.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN apt-get install python=2.7</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN apt-get install -y python=2.7</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3015</key>
		<name><![CDATA[Avoid additional packages by specifying --no-install-recommends.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Avoid installing additional packages that you did not explicitly want.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt-get install -y python=2.7</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install -y --no-install-recommends python=2.7</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3016</key>
		<name><![CDATA[Pin versions in npm.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.
				<blockquote><a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM node:8.9.1

RUN npm install express
RUN npm install @myorg/privatepackage
RUN npm install express sax@0.1.1
RUN npm install --global express
RUN npm install git+ssh://git@github.com:npm/npm.git
RUN npm install git+http://isaacs@github.com/npm/npm
RUN npm install git+https://isaacs@github.com/npm/npm.git
RUN npm install git://github.com/npm/npm.git</pre>
			<h2>Correct code :</h2>
			<pre>FROM node:8.9.1

RUN npm install express@4.1.1
RUN npm install @myorg/privatepackage@">=0.1.0"
RUN npm install express@"4.1.1" sax@0.1.1
RUN npm install --global express@"4.1.1"
RUN npm install git+ssh://git@github.com:npm/npm.git#v1.0.27
RUN npm install git+http://isaacs@github.com/npm/npm#semver:^5.0
RUN npm install git+https://isaacs@github.com/npm/npm.git#v1.0.27
RUN npm install git://github.com/npm/npm.git#v1.0.27</pre>
			<h2>Exceptions :</h2>
			<p>Pin your versions in <b>package.json</b> and run <b>npm install</b> with no arguments.</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3017</key>
		<name><![CDATA[Do not use apk upgrade]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				You should avoid <b>RUN apk upgrade</b>, as many of the “essential” packages from the parent images won’t upgrade inside an unprivileged container. If a package contained in the parent image is out-of-date, you should contact its maintainers. If you know there’s a particular package, <b>foo</b>, that needs to be updated, use <b>apk --no-cache add foo</b> to update automatically.
				<blockquote>inspired by <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk update \
    && apk upgrade \
    && apk add foo=1.0 \
    && rm -rf /var/cache/apk/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.0</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3018</key>
		<name><![CDATA[Pin versions in apk add]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Version pinning forces the build to retrieve a limited range of versions, or an exact particular version, regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.
				<blockquote><a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo</pre>
			<h2>Correct code (Partial pin glob):</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=~1.23</pre>
			<h2>Correct code (Exact pin):</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.23</pre>
			<p><b>Note:</b> Pinning exact versions can cause future builds to suddenly fail if that version is no longer available. Use with caution.</p>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3019</key>
		<name><![CDATA[Use the --no-cache switch]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				As of Alpine Linux 3.3 there exists a new <b>--no-cache</b> option for <b>apk</b>. It allows users to install packages with an index that is updated and used on-the-fly and not cached locally:</br>
This avoids the need to use <b>--update</b> and remove <b>/var/cache/apk/*</b> when done installing packages.
				<blockquote>inspired by <a href="https://github.com/gliderlabs/docker-alpine/blob/master/docs/usage.md#disabling-cache">https://github.com/gliderlabs/docker-alpine/blob/master/docs/usage.md#disabling-cache</a></blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM alpine:3.7
RUN apk update \
    && apk add foo=1.0 \
    && rm -rf /var/cache/apk/*</pre>
			<pre>FROM alpine:3.7
RUN apk add --update foo=1.0
    && rm -rf /var/cache/apk/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM alpine:3.7
RUN apk --no-cache add foo=1.0</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3020</key>
		<name><![CDATA[Use COPY instead of ADD for files and folders]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy</a>
				<blockquote>For other items (files, directories) that do not require ADD’s tar auto-extraction capability, you should always use COPY.</blockquote>
				Rule also implemented in <a href="https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee">https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee</a>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM python:3.4
ADD requirements.txt /usr/src/app/*</pre>
			<h2>Correct code :</h2>
			<pre>FROM python:3.4
COPY requirements.txt /usr/src/app/</pre>
			]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3021</key>
		<name><![CDATA[COPY with more than 2 arguments requires the last argument to end with /]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<a href="https://docs.docker.com/engine/reference/builder/#copy">https://docs.docker.com/engine/reference/builder/#copy</a>
				<blockquote>If multiple resources are specified, either directly or due to the use of a wildcard, then must be a directory, and it must end with a slash /</blockquote>
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM node:carbon
COPY package.json yarn.lock my_app</pre>
			<h2>Correct code :</h2>
			<pre>FROM node:carbon
COPY package.json yarn.lock my_app/</pre>
			]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3022</key>
		<name><![CDATA[COPY --from should reference a previously defined FROM alias]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Trying to copy from a missing image alias results in an error.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:jesse
RUN stuff
FROM debian:jesse
COPY --from=build some stuff ./</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jesse as build
RUN stuff
FROM debian:jesse
COPY --from=build some stuff ./</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3023</key>
		<name><![CDATA[COPY --from cannot reference its own FROM alias]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Trying to copy from the same image the instruction is running in results in an error.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:jesse as build
COPY --from=build some stuff ./</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jesse as build
RUN stuff
FROM debian:jesse
COPY --from=build some stuff ./</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3024</key>
		<name><![CDATA[FROM aliases (stage names) must be unique]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Defining duplicate stage names results in an error.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian:jesse as build
RUN stuff
FROM debian:jesse as build
RUN more_stuff</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian:jesse as build
RUN stuff
FROM debian:jesse as another-alias
RUN more_stuff</pre>]]>
		</description>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>BUG</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3025</key>
		<name><![CDATA[Use arguments JSON notation for CMD and ENTRYPOINT arguments]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Trying to copy from the same image the instruction is running in results in an error.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
ENTRYPOINT s3cmd</pre>
			<pre>FROM busybox
CMD my-service server</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
ENTRYPOINT ["s3cmd"]</pre>
			<pre>FROM busybox
CMD ["my-service", "server"]</pre>
			<p>
				<b>Warning:</b> Docker <b>CMD</b> does not process <b>$ENVIRONMENT_VARIABLE</b>s, that’s a side-effect of using <b>sh -c</b> as the default entry-point. Using the JSON notation means that you have to figure out how to handle environment variables yourself.
			</p>
			<p>
				<b>Warning:</b> The <b>CMD</b> exec form is parsed as a JSON array, so you <b>MUST</b> use double quotes (") instead of single quote (').
			</p>
			See <a href="https://docs.docker.com/v17.09/engine/reference/builder/#cmd">https://docs.docker.com/v17.09/engine/reference/builder/#cmd</a> for more info.]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3026</key>
		<name><![CDATA[Use only an allowed registry in the FROM image]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Using the <b>FROM</b> instruction is a huge exercise in trust, you have to trust that a particular version or an image is safe for you to use, and that it will never be retagged maliciously. In order to prevent that, some companies copy trusted images into their own repositories, and reference them directly.
			</p>
			<p>For example, this would be an untrusted image :</p>
			<pre>FROM randomguy/fancy:10
...</pre>
			<p>But after an audit, the company decides to copy the image into their own repository, as it was deemed safe :</p>
			<pre>FROM my-registry.com/fancy:10
...</pre>
			<p>The idea is that hadolint can warn whenever an untrusted repo is used, you can use the <b>--trusted-registry</b> flag for that</p>
			<pre>hadolint --trusted-registry my-registry.com Dockerfile</pre>
			<h2>Problematic code :</h2>
			<pre>FROM randomguy/python:3.6
...</pre>
			<h2>Correct code :</h2>
			<pre>FROM my-registry.com/python:3.6
...</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>VULNERABILITY</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>30min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3027</key>
		<name><![CDATA[Do not use apt as it is meant to be an end-user tool, use apt-get or apt-cache instead.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<b>apt</b> is discouraged by the linux distributions as an unattended tool as its interface may suffer changes between versions. Better use the more stable <b>apt-get</b> and <b>apt-cache</b>
			<p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
RUN apt install curl=1.1.0</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
RUN apt-get install curl=1.1.0</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3028</key>
		<name><![CDATA[Pin versions in gem install]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">https://docs.docker.com/engine/articles/dockerfile_best-practices/</a>
			<blockquote>Version pinning forces the build to retrieve a particular version regardless of what’s in the cache. This technique can also reduce failures due to unanticipated changes in required packages.</blockquote>
			<h2>Problematic code :</h2>
			<pre>FROM ruby:2
RUN gem install bundler</pre>
			<h2>Correct code :</h2>
			<pre>FROM ruby:2
RUN gem install bundler:1.1</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL3029</key>
		<name><![CDATA[Do not use --platform= with FROM.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Specifying <b>--platform=</b> in the <a href="https://docs.docker.com/engine/reference/builder/#from">docker file FROM clause</a> forces the Image to build only one target platform. This has a number of negative consequences:
				<ul>
    				<li>It is not possible to build a <a href="https://www.docker.com/blog/docker-official-images-now-multi-platform/">multi-platform Image</a> from this Docker file.</li>
    				<li>The platform that you build on must be the same as the platform specified in <b>--platform=</b></li>
				</ul>
				A better approach is to omit <b>FROM --platform</b> in the docker file and to specify in <b>buildx --platform=</b> during the build if control of the image platform target is needed.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM --platform=x86 busybox</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4000</key>
		<name><![CDATA[MAINTAINER is deprecated]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				<b>MAINTAINER</b> is deprecated since Docker 1.13.0 <a href="https://github.com/lukasmartinelli/hadolint/issues/71">https://github.com/lukasmartinelli/hadolint/issues/71</a>.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
MAINTAINER Lukas Martinelli <me@lukasmartinelli.ch></pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>5min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4001</key>
		<name><![CDATA[Either use Wget or Curl but not both.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Don't install two tools that have the same effect and avoid the additional cruft.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM debian
RUN wget http://google.com
RUN curl http://bing.com</pre>
			<h2>Correct code :</h2>
			<pre>FROM debian
RUN curl http://google.com
RUN curl http://bing.com</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>20min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4003</key>
		<name><![CDATA[Multiple CMD instructions found. If you list more than one CMD then only the last CMD will take effect.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Rule also implemented in <a href="https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee">https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee</a>.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
CMD /bin/true
CMD /bin/false</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
CMD /bin/false</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4004</key>
		<name><![CDATA[Multiple ENTRYPOINT instructions found. If you list more than one ENTRYPOINT then only the last ENTRYPOINT will take effect.]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Rule also implemented in <a href="https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee">https://github.com/RedCoolBeans/dockerlint/blob/master/src/checks.coffee</a>.
			</p>
			<h2>Problematic code :</h2>
			<pre>FROM busybox
ENTRYPOINT /bin/true
ENTRYPOINT /bin/false</pre>
			<h2>Correct code :</h2>
			<pre>FROM busybox
ENTRYPOINT /bin/false</pre>]]>
		</description>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4005</key>
		<name><![CDATA[Use SHELL to change the default shell]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<p>
				Docker provides a <a href="https://docs.docker.com/engine/reference/builder/#/shell"><b>SHELL</b> instruction</a> which does not require overwriting <b>/bin/sh</b>	 in your container.	
			</p>
			<h2>Problematic code :</h2>
			<pre># Install bash
RUN apk add --update-cache bash=4.3.42-r3

# Use bash as the default shell
RUN ln -sfv /bin/bash /bin/sh</pre>
			<h2>Correct code :</h2>
			<pre># Install bash
RUN apk add --update-cache bash=4.3.42-r3

# Use bash as the default shell
SHELL ["/bin/bash", "-c"]</pre>]]>
		</description>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>10min</remediationFunctionBaseEffort>
	</rule>
	<rule>
		<key>Hadolint.DL4006</key>
		<name><![CDATA[Set the SHELL option -o pipefail before RUN with a pipe in]]></name>
		<description><![CDATA[
			<h2>Rationale :</h2>
			<blockquote><a href="https://github.com/docker/docker.github.io/blob/master/develop/develop-images/dockerfile_best-practices.md#using-pipes">https://github.com/docker/docker.github.io/blob/master/develop/develop-images/dockerfile_best-practices.md#using-pipes</a></blockquote>
			<p>Some <b>RUN</b> commands depend on the ability to pipe the output of one command into another, using the pipe character (|), as in the following example:</p>
			<pre>RUN wget -O - https://some.site | wc -l > /number</pre>
			<p>
				Docker executes these commands using the <b>/bin/sh -c</b> interpreter, which only evaluates the exit code of the last operation in the pipe to determine success. In the example above this build step succeeds and produces a new image so long as the <b>wc -l</b> command succeeds, even if the <b>wget</b> command fails.
			</p>
			<p>
				If you want the command to fail due to an error at any stage in the pipe, prepend <b>set -o pipefail &&</b> to ensure that an unexpected error prevents the build from inadvertently succeeding.
			</p>
			<p>
				Since there are some shells that do not accept the <b>-o pipefail</b> option, it is not enough to add <b>set -o pipefail</b> inside the <b>RUN</b> instruction. Therefore, we recommend to always explicitly the <b>SHELL</b> before using pipes in <b>RUN</b>.
			</p>
			<h2>Problematic code :</h2>
			<pre>RUN wget -O - https://some.site | wc -l > /number</pre>
			<h2>Correct code :</h2>
			<pre>SHELL ["/bin/bash", "-o", "pipefail", "-c"]
RUN wget -O - https://some.site | wc -l > /number</pre>
			<p>Or in case of busybox in an Alpine image:</p>
			<pre>SHELL ["/bin/ash", "-eo", "pipefail", "-c"]
RUN wget -O - https://some.site | wc -l > /number</pre>]]>
		</description>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<type>CODE_SMELL</type>
		<remediationFunction>CONSTANT_ISSUE</remediationFunction>
		<remediationFunctionBaseEffort>15min</remediationFunctionBaseEffort>
	</rule>

</hadolint-rules>